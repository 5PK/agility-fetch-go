/*
Agility CMS REST API

Agility CMS REST API for retrieving content from the Agility CMS.  The API Types are fetch (for published content) and preview (for latest, or staging content).

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package agilitycms

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	 
)


// UrlRedirectionAPIService UrlRedirectionAPI service
type UrlRedirectionAPIService service

type UrlredirectionGetRequest struct {
	ctx context.Context
	ApiService *UrlRedirectionAPIService
	guid string
	apitype APIType
	lastAccessDate *string
}

// The last access date/time that the URL Redirections list was previously accessed, eg: 2020-09-24T10:00:00.00-04:00.
func (r UrlredirectionGetRequest) LastAccessDate(lastAccessDate string) UrlredirectionGetRequest {
	r.lastAccessDate = &lastAccessDate
	return r
}

func (r UrlredirectionGetRequest) Execute() ([]UrlRedirection, *http.Response, error) {
	return r.ApiService.UrlredirectionGetExecute(r)
}

/*
UrlredirectionGet Gets the list of all URL Redirections since a particular date/time. Persist the lastAccessDate that is returned and use that value to maintain state on subsequent requests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The instance GUID, available from the API Keys section.
 @param apitype The Type of API - fetch or preview.
 @return UrlredirectionGetRequest
*/
func (a *UrlRedirectionAPIService) UrlredirectionGet(ctx context.Context, guid string, apitype APIType) UrlredirectionGetRequest {
	return UrlredirectionGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		apitype: apitype,
	}
}

// Execute executes the request
//  @return []UrlRedirection
func (a *UrlRedirectionAPIService) UrlredirectionGetExecute(r UrlredirectionGetRequest) ([]UrlRedirection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UrlRedirection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UrlRedirectionAPIService.UrlredirectionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{guid}/{apitype}/urlredirection"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apitype"+"}", url.PathEscape(parameterValueToString(r.apitype, "apitype")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lastAccessDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastAccessDate", r.lastAccessDate, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyAuthorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["APIKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
