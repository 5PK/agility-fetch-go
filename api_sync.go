/*
Agility CMS REST API

Agility CMS REST API for retrieving content from the Agility CMS.  The API Types are fetch (for published content) and preview (for latest, or staging content).

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package agilitycms

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SyncAPIService SyncAPI service
type SyncAPIService service

type LocaleSyncItemsGetRequest struct {
	ctx context.Context
	ApiService *SyncAPIService
	guid string
	apitype APIType
	locale string
	syncToken *int64
	pageSize *int32
}

// The token from the most recently synced value.
func (r LocaleSyncItemsGetRequest) SyncToken(syncToken int64) LocaleSyncItemsGetRequest {
	r.syncToken = &syncToken
	return r
}

// The number of items to return per set.
func (r LocaleSyncItemsGetRequest) PageSize(pageSize int32) LocaleSyncItemsGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r LocaleSyncItemsGetRequest) Execute() (*HeadlessContentItemHeadlessSync, *http.Response, error) {
	return r.ApiService.SyncItemsGetExecute(r)
}

/*
SyncItemsGet Retrieves all content items in a paged format.  Each call returns a sync token that should be persisted and passed into subsequent requests to maintain sync state.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The instance GUID, available from the API Keys section.
 @param apitype The Type of API - fetch or preview.
 @param locale The locale code you want to sync content items for.
 @return LocaleSyncItemsGetRequest
*/
func (a *SyncAPIService) SyncItemsGet(ctx context.Context, guid string, apitype APIType, locale string) LocaleSyncItemsGetRequest {
	return LocaleSyncItemsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		apitype: apitype,
		locale: locale,
	}
}

// Execute executes the request
//  @return HeadlessContentItemHeadlessSync
func (a *SyncAPIService) SyncItemsGetExecute(r LocaleSyncItemsGetRequest) (*HeadlessContentItemHeadlessSync, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HeadlessContentItemHeadlessSync
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncAPIService.SyncItemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{guid}/{apitype}/{locale}/sync/items"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apitype"+"}", url.PathEscape(parameterValueToString(r.apitype, "apitype")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.syncToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "syncToken", r.syncToken, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 500
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyAuthorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["APIKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type LocaleSyncPagesGetRequest struct {
	ctx context.Context
	ApiService *SyncAPIService
	guid string
	apitype APIType
	locale string
	syncToken *int64
	pageSize *int32
}

// The token from the most recently synced value.
func (r LocaleSyncPagesGetRequest) SyncToken(syncToken int64) LocaleSyncPagesGetRequest {
	r.syncToken = &syncToken
	return r
}

// The number of items to return per set.
func (r LocaleSyncPagesGetRequest) PageSize(pageSize int32) LocaleSyncPagesGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r LocaleSyncPagesGetRequest) Execute() (*HeadlessContentPageHeadlessSync, *http.Response, error) {
	return r.ApiService.SyncPagesGetExecute(r)
}

/*
SyncPagesGet Retrieves all pages items in a paged format.  Each call returns a sync token that should be persisted and passed into subsequent requests to maintain sync state.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The instance GUID, available from the API Keys section.
 @param apitype The Type of API - fetch or preview.
 @param locale The locale code you want to sync pages for.
 @return LocaleSyncPagesGetRequest
*/
func (a *SyncAPIService) SyncPagesGet(ctx context.Context, guid string, apitype APIType, locale string) LocaleSyncPagesGetRequest {
	return LocaleSyncPagesGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		apitype: apitype,
		locale: locale,
	}
}

// Execute executes the request
//  @return HeadlessContentPageHeadlessSync
func (a *SyncAPIService) SyncPagesGetExecute(r LocaleSyncPagesGetRequest) (*HeadlessContentPageHeadlessSync, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HeadlessContentPageHeadlessSync
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncAPIService.SyncPagesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{guid}/{apitype}/{locale}/sync/pages"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apitype"+"}", url.PathEscape(parameterValueToString(r.apitype, "apitype")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.syncToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "syncToken", r.syncToken, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 500
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyAuthorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["APIKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
