/*
Agility CMS REST API

Agility CMS REST API for retrieving content from the Agility CMS.  The API Types are fetch (for published content) and preview (for latest, or staging content).

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package agilitycms

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PageAPIService PageAPI service
type PageAPIService service

type LocalePageChannelGetRequest struct {
	ctx context.Context
	ApiService *PageAPIService
	guid string
	apitype APIType
	locale string
	channel string
	path *string
	contentLinkDepth *int32
	expandAllContentLinks *bool
}

// The path of the page
func (r LocalePageChannelGetRequest) Path(path string) LocalePageChannelGetRequest {
	r.path = &path
	return r
}

// The maximum level to expand linked content from this item
func (r LocalePageChannelGetRequest) ContentLinkDepth(contentLinkDepth int32) LocalePageChannelGetRequest {
	r.contentLinkDepth = &contentLinkDepth
	return r
}

// Whether or not to expand entire linked content references, includings lists and items that are rendered in the CMS as Grid or Link and linked to modules or linked items on this page.
func (r LocalePageChannelGetRequest) ExpandAllContentLinks(expandAllContentLinks bool) LocalePageChannelGetRequest {
	r.expandAllContentLinks = &expandAllContentLinks
	return r
}

func (r LocalePageChannelGetRequest) Execute() (*HeadlessContentPageByPath, *http.Response, error) {
	return r.ApiService.PageChannelGetExecute(r)
}

/*
PageChannelGet Gets the details of a page by its Page path, in a specific channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The instance GUID, available from the API Keys section.
 @param apitype The API type (preview, fetch).
 @param locale The locale code you want to retrieve content for.
 @param channel The reference name of the digital channel of the sitemap to return. If you only have one channel, your channel reference name is likely 'website'.
 @return LocalePageChannelGetRequest
*/
func (a *PageAPIService) PageChannelGet(ctx context.Context, guid string, apitype APIType, locale string, channel string) LocalePageChannelGetRequest {
	return LocalePageChannelGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		apitype: apitype,
		locale: locale,
		channel: channel,
	}
}

// Execute executes the request
//  @return HeadlessContentPageByPath
func (a *PageAPIService) PageChannelGetExecute(r LocalePageChannelGetRequest) (*HeadlessContentPageByPath, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HeadlessContentPageByPath
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageAPIService.PageChannelGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{guid}/{apitype}/{locale}/page/{channel}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apitype"+"}", url.PathEscape(parameterValueToString(r.apitype, "apitype")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"channel"+"}", url.PathEscape(parameterValueToString(r.channel, "channel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	if r.contentLinkDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentLinkDepth", r.contentLinkDepth, "form", "")
	} else {
		var defaultValue int32 = 2
		r.contentLinkDepth = &defaultValue
	}
	if r.expandAllContentLinks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expandAllContentLinks", r.expandAllContentLinks, "form", "")
	} else {
		var defaultValue bool = false
		r.expandAllContentLinks = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyAuthorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["APIKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PageIdGetRequest struct {
	ctx context.Context
	ApiService *PageAPIService
	guid string
	apitype APIType
	locale string
	id int32
	contentLinkDepth *int32
	expandAllContentLinks *bool
}

// The maximum level to expand linked content from this item
func (r PageIdGetRequest) ContentLinkDepth(contentLinkDepth int32) PageIdGetRequest {
	r.contentLinkDepth = &contentLinkDepth
	return r
}

// Whether or not to expand entire linked content references, includings lists and items that are rendered in the CMS as Grid or Link and linked to modules or linked items on this page.
func (r PageIdGetRequest) ExpandAllContentLinks(expandAllContentLinks bool) PageIdGetRequest {
	r.expandAllContentLinks = &expandAllContentLinks
	return r
}

func (r PageIdGetRequest) Execute() (*HeadlessContentPage, *http.Response, error) {
	return r.ApiService.PageIdGetExecute(r)
}

/*
PageIdGet Gets the details of a page by its Page ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The instance GUID, available from the API Keys section.
 @param apitype The API type (preview, fetch).
 @param locale The locale code you want to retrieve content for.
 @param id The unique page ID of the page you wish to retrieve in the current locale.
 @return PageIdGetRequest
*/
func (a *PageAPIService) PageIdGet(ctx context.Context, guid string, apitype APIType, locale string, id int32) PageIdGetRequest {
	return PageIdGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		apitype: apitype,
		locale: locale,
		id: id,
	}
}

// Execute executes the request
//  @return HeadlessContentPage
func (a *PageAPIService) PageIdGetExecute(r PageIdGetRequest) (*HeadlessContentPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HeadlessContentPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageAPIService.PageIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{guid}/{apitype}/{locale}/page/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apitype"+"}", url.PathEscape(parameterValueToString(r.apitype, "apitype")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contentLinkDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contentLinkDepth", r.contentLinkDepth, "form", "")
	} else {
		var defaultValue int32 = 2
		r.contentLinkDepth = &defaultValue
	}
	if r.expandAllContentLinks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expandAllContentLinks", r.expandAllContentLinks, "form", "")
	} else {
		var defaultValue bool = false
		r.expandAllContentLinks = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyAuthorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["APIKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundResult
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
