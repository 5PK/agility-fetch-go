/*
Agility CMS REST API

Agility CMS REST API for retrieving content from the Agility CMS.  The API Types are fetch (for published content) and preview (for latest, or staging content).

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package agilitycms

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ListAPIService ListAPI service
type ListAPIService service

type LocaleListReferenceNameGetRequest struct {
	ctx context.Context
	ApiService *ListAPIService
	guid string
	apitype APIType
	locale string
	referenceName string
	contentLinkDepth *int32
	expandAllContentLinks *bool
	fields *string
	take *int32
	skip *int32
	filter *string
	sort *string
	direction *string
}

// [Optional] The depth of list items. Maximum allowed is 5.
func (r LocaleListReferenceNameGetRequest) ContentLinkDepth(contentLinkDepth int32) LocaleListReferenceNameGetRequest {
	r.contentLinkDepth = &contentLinkDepth
	return r
}

// [Optional] Whether or not to expand entire linked content references, includings lists and items that are rendered in the CMS as Grid or Link.
func (r LocaleListReferenceNameGetRequest) ExpandAllContentLinks(expandAllContentLinks bool) LocaleListReferenceNameGetRequest {
	r.expandAllContentLinks = &expandAllContentLinks
	return r
}

// [Optional] A comma separated list of the fields to return.
func (r LocaleListReferenceNameGetRequest) Fields(fields string) LocaleListReferenceNameGetRequest {
	r.fields = &fields
	return r
}

// [Optional] The maximum number of items to retrieve in this request. Default is 10. Maximum allowed is 250.
func (r LocaleListReferenceNameGetRequest) Take(take int32) LocaleListReferenceNameGetRequest {
	r.take = &take
	return r
}

// [Optional] The number of items to skip from the list. Default is 0. Used for implementing pagination.
func (r LocaleListReferenceNameGetRequest) Skip(skip int32) LocaleListReferenceNameGetRequest {
	r.skip = &skip
	return r
}

// [Optional] The filter you wish to apply to the list query. Supports [eq (Equal To), ne (Not Equal), lt (Less Than), lte (Less Than or Equal), gt (Greater Than), gte (Greater Than or Equal)]. Example value: &#x60;fields.title[eq]\&quot;some title\&quot; or fields.details[like]\&quot;some text\&quot;&#x60;
func (r LocaleListReferenceNameGetRequest) Filter(filter string) LocaleListReferenceNameGetRequest {
	r.filter = &filter
	return r
}

// [Optional] The field to sort the results by. Example fields.title or properties.created, seo.metaDescription
func (r LocaleListReferenceNameGetRequest) Sort(sort string) LocaleListReferenceNameGetRequest {
	r.sort = &sort
	return r
}

// [Optional] The direction to sort the results by. Default is asc. Valid values are asc, desc.
func (r LocaleListReferenceNameGetRequest) Direction(direction string) LocaleListReferenceNameGetRequest {
	r.direction = &direction
	return r
}

func (r LocaleListReferenceNameGetRequest) Execute() (*HeadlessContentListResponse, *http.Response, error) {
	return r.ApiService.ListReferenceNameGetExecute(r)
}

/*
ListReferenceNameGet Retrieves a list of content items by reference name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The instance GUID, available from the API Keys section.
 @param apitype The API type (preview, fetch).
 @param locale The locale code you want to retrieve content for.
 @param referenceName The unique reference name of the content list you wish to retrieve in the current locale. Reference names must be ALL lowercase.
 @return LocaleListReferenceNameGetRequest
*/
func (a *ListAPIService) ListReferenceNameGet(ctx context.Context, guid string, apitype APIType, locale string, referenceName string) LocaleListReferenceNameGetRequest {
	return LocaleListReferenceNameGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		apitype: apitype,
		locale: locale,
		referenceName: referenceName,
	}
}

// Execute executes the request
//  @return HeadlessContentListResponse
func (a *ListAPIService) ListReferenceNameGetExecute(r LocaleListReferenceNameGetRequest) (*HeadlessContentListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HeadlessContentListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListAPIService.ListReferenceNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{guid}/{apitype}/{locale}/list/{referenceName}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apitype"+"}", url.PathEscape(parameterValueToString(r.apitype, "apitype")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"locale"+"}", url.PathEscape(parameterValueToString(r.locale, "locale")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"referenceName"+"}", url.PathEscape(parameterValueToString(r.referenceName, "referenceName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contentLinkDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ContentLinkDepth", r.contentLinkDepth, "form", "")
	}
	if r.expandAllContentLinks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExpandAllContentLinks", r.expandAllContentLinks, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Fields", r.fields, "form", "")
	}
	if r.take != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Take", r.take, "form", "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Skip", r.skip, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filter", r.filter, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Sort", r.sort, "form", "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Direction", r.direction, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyAuthorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["APIKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
